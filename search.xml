<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[html学习总结]]></title>
    <url>%2Fpost%2F5be4bf9f.html</url>
    <content type="text"><![CDATA[HTML的常见用法总结： 常用标签：123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 标题：代码123456&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt;效果:一级标题二级标题三级标题四级标题五级标题六级标题 段落： 代码：123&lt;p&gt;这是段落。&lt;/p&gt;&lt;p&gt;会换行。&lt;/p&gt;换行&lt;/br&gt; 效果：这是段落。会换行。换行 图片： 代码： 1 &lt;img src="",title="",height="",width="",alt=""&gt; src=””;引号中间接图片地址 title=””;引号中间接标题 height=””;图片的高度 width=””;图片的宽度 alt=””;无法显示图片时 链接 代码 1&lt;a href=""&gt;name&lt;/a&gt; hred=””;引号中间为链接地址 name处为名称 常见作用：跳转，瞄（当href=“#某个标签的id”时，就可以跳转） 表格 代码 12345678 &lt;table&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; tr表示行 th表示头标题 td表示格子内容]]></content>
  </entry>
  <entry>
    <title><![CDATA[vector总结（三）]]></title>
    <url>%2Fpost%2F67a66973.html</url>
    <content type="text"><![CDATA[实现一个vector类 框架来自邓俊辉老师的例子：vector.h 具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190template&lt;typename T&gt;class myVector&#123; T *_data; int _size; void copyFrom(T const *A,int lo,int hi);//复制数组区间 void expand();//空间不足时扩容 void shrink();//装填因子过小时压缩 public: myVector(int =0,T =0); myVector(const T *A,int lo,int hi); myVector(const myVector&lt;T&gt; &amp;mv); int size() const;//报告向量当前的规模（元素总数） T get(int r) const;//获取秩为r的元素 void put(int r,T e);//用e替换秩为r元素的数值 void insert(int r,T e);//插入元素 T remove(int r);//删除秩为r的元素 int remove(int lo,int hi);//删除秩在区间[lo, hi]之内的元素 bool disortered() const;//判断向量是否已排序 void sort();//调整各元素的位置，使之按非降序排列 int find(T e) const;//无序向量整体查找 int search(T e) const;//有序向量整体查找 void deduplicate();//无序剔除重复元素 void uniquify();//有序剔除重复元素 void show();&#125;; //复制数组区间template&lt;typename T&gt;void myVector&lt;T&gt;::copyFrom(T const *A,int lo,int hi)&#123; for(int i=lo;i&lt;hi;i++) _data[i-lo]=A[i]; _size=hi-lo+1;&#125;//空间不足时扩容template&lt;typename T&gt;void myVector&lt;T&gt;::expand()&#123; T* oldData=_data; _data=new T[_size&lt;&lt;1]; for(int i=0;i&lt;_size;i++) _data[i]=oldData[i]; _size&lt;&lt;=1; delete []oldData;&#125;//装填因子过小时压缩template&lt;typename T&gt;void myVector&lt;T&gt;::shrink()&#123; T* oldData=_data; _data=new T[_size&gt;&gt;=1]; for(int i=0;i&lt;_size;i++) _data[i]=oldData[i]; delete []oldData;&#125;template&lt;typename T&gt;myVector&lt;T&gt;::myVector(int size,T a):_size(size),_data(new T(size))&#123; for(int i=0;i&lt;_size;i++) _data[i]=a;&#125;template&lt;typename T&gt;myVector&lt;T&gt;::myVector(const myVector&lt;T&gt;&amp; mv)&#123; copyFrom(mv._data,0,mv._size);&#125;template&lt;typename T&gt;myVector&lt;T&gt;::myVector(const T *A,int lo,int hi)&#123; copyFrom(A,lo,hi);&#125;//报告向量当前的规模（元素总数） template&lt;typename T&gt;int myVector&lt;T&gt;::size() const&#123;return _size;&#125;//获取秩为r的元素 template&lt;typename T&gt;T myVector&lt;T&gt;::get(int r) const&#123;return _data[r];&#125;//用e替换秩为r元素的数值template&lt;typename T&gt;void myVector&lt;T&gt;::put(int r,T e)&#123;_data[r]=e;&#125;//插入元素template&lt;typename T&gt;void myVector&lt;T&gt;::insert(int r,T e)&#123; _size++; for(int i=_size;i&gt;r;i--) _data[i]=_data[i-1]; _data[r]=e; &#125;//删除秩为r的元素template&lt;typename T&gt;T myVector&lt;T&gt;::remove(int r)&#123; for(int i=r;i&lt;_size;i++) _data[i]=_data[i+1]; _size--;&#125;//删除秩在区间[lo, hi]之内的元素template&lt;typename T&gt;int myVector&lt;T&gt;::remove(int lo,int hi)&#123; for(int i=lo,j=hi+1;j&lt;_size;i++,j++) _data[i]=_data[j]; _size-=(hi-lo+1);&#125;//判断向量是否已排序template&lt;typename T&gt;bool myVector&lt;T&gt;::disortered() const&#123; for(int i=1;i&lt;_size;i++) if(_data[i]&gt;_data[i-1]) return false; return true;&#125; //调整各元素的位置，使之按非降序排列 template&lt;typename T&gt;void myVector&lt;T&gt;::sort()&#123; merge_sort(_data);&#125;//无序向量整体查找template&lt;typename T&gt;int myVector&lt;T&gt;::find(T e) const&#123; for(int i=0;i&lt;_size;i++) if(_data[i]==e) return i; return -1;&#125;//有序向量整体查找template&lt;typename T&gt;int myVector&lt;T&gt;::search(T e) const&#123; bin_search(_data,e);&#125;//无序剔除重复元素template&lt;typename T&gt;void myVector&lt;T&gt;::deduplicate()&#123; cout&lt;&lt;_size&lt;&lt;endl; for(int i=0;i&lt;_size-1;i++)&#123; for(int j=i+1;j&lt;_size;) if(_data[j]==_data[i]) remove(j); else j++; &#125; cout&lt;&lt;_size&lt;&lt;endl;&#125;//有序剔除重复元素template&lt;typename T&gt;void myVector&lt;T&gt;::uniquify()&#123; for(int i=0,j=0;j&lt;_size;j++) if(_data[j]!=_data[i]) _data[j]=_data[++i];&#125;template&lt;typename T&gt;void myVector&lt;T&gt;::show()&#123; for(int i=0;i&lt;_size;i++) cout&lt;&lt;_data[i]&lt;&lt;' '; cout&lt;&lt;endl;&#125;int main()&#123; myVector&lt;int&gt; mv; mv.insert(0,9); mv.show(); mv.insert(0,4); mv.show(); mv.insert(1,5); mv.show(); mv.put(1,2); mv.show(); cout&lt;&lt;mv.get(2)&lt;&lt;endl; mv.insert(3,6); mv.show(); mv.insert(1,7); mv.show(); mv.remove(2); mv.show(); mv.insert(1,3); mv.show(); mv.insert(3,4); mv.show(); cout&lt;&lt;mv.size()&lt;&lt;endl; cout&lt;&lt;mv.disortered()&lt;&lt;endl; cout&lt;&lt;mv.find(9)&lt;&lt;endl; cout&lt;&lt;mv.find(5)&lt;&lt;endl; cout&lt;&lt;mv.disortered()&lt;&lt;endl; mv.deduplicate(); mv.show();&#125; 结果如图：]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vector总结（二）]]></title>
    <url>%2Fpost%2F2ab8ca21.html</url>
    <content type="text"><![CDATA[主题：数组的排序方法 插入排序 概念：插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)，是稳定的排序方法。 代码实现： 1234567891011void insert_sort(vector&lt;int&gt;&amp; vec)&#123; int n=vec.size(); for(int i=1;i&lt;n;i++)&#123; int j=i-1,tg=vec[i]; while(j&gt;=0&amp;&amp;vec[j]&gt;tg)&#123; vec[j+1]=vec[j];//插入 j--; &#125; vec[j+1]=tg; &#125;&#125; 特点：从前往后迭代，从后往前移动（插入特点）。 递归形式： 12345678910111213141516void insert_sort(vector&lt;int&gt;&amp; vec,int n)&#123; if(n==0) return; else&#123; insert_sort(vec,n-1);//前（n-1）排序 insert(vec,n);//插入第n个 &#125;&#125;void insert(vector&lt;int&gt;&amp;vec,int n)&#123; int i=n-1,tg=vec[n]; while(i&gt;=0&amp;&amp;vec[i]&gt;tg)&#123; vec[i+1]=vec[i]; i--; &#125; vec[i+1]=tg;&#125; 归并排序 概念：将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序，是稳定的排序方法。 代码实现： 123456789101112131415161718192021222324void merge_sort(vector&lt;int&gt;&amp; vec,int l,int r)&#123; if(l&gt;=r) return; else&#123; int mi=(l+r)&gt;&gt;1; merge_sort(vec,l,mi); merge_sort(vec,mi+1,r); merge(vec,l,mi,r); &#125;&#125;void merge(vector&lt;int&gt;&amp;vec,int l,int mi,int r)&#123; int l1=mi-l+1,l2=r-mi; int *A=new int[l1]; for(int i=0;i&lt;l1;i++) A[i]=vec[l+i]; int *B=new int[l2]; for(int i=0;i&lt;l2;i++) B[i]=vec[mi+1+i];//亦可设置哨兵 for(int i=0,j=0,k=l;i&lt;l1||j&lt;l2;k++)&#123; if(j==l2||(i&lt;l1&amp;&amp;j&lt;l2&amp;&amp;A[i]&lt;=B[j])) vec[k]=A[i++]; else vec[k]=B[j++]; &#125; delete []A; delete []B;&#125; 特点：分治法，重在合。 时间复杂度：O(nlog n) 新增： 快速排序 概念：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序。 代码实现： 123456789101112131415161718void quicksort(vector&lt;int&gt;&amp; vec,int l,int r)&#123; if(l-r&lt;=1) return ; int mi=partition(vec,l,r);//查找端点 quicksort(vec,l,mi); quicksott(vec,mi+1,hi);&#125;int partition(vector&lt;int&gt; &amp;vec,int l,int r)&#123; int u=l; int pivot=vec[u]; while(l&lt;r)&#123; while(l&lt;r&amp;&amp;pivot&lt;=vec[r]) r--; if(l&lt;r) vec[l]=vec[r]; //找到比端点小的，就放到l处； while(l&lt;r&amp;&amp;vec[l]&lt;=pivot) l++; if(l&lt;r) vec[r]=vec[l]; //找到比端点值大的，就放到r处 &#125; vec[l]=pivot; return l;//返回端点&#125; 特点：分治法，重在分。 时间复杂度：O(nlog n) 冒泡排序改进特点：检测最后的逆序对的位置，减少循环次数，但时间复杂度还是O(n)。 代码实现： 1234567891011121314void bubble_sort(vector&lt;int&gt;&amp; vec)&#123; int last,hi; hi=vec.size(); last=0;//最后的逆序对位置 for(int i=0;i&lt;hi;i++)&#123; for(int j=0;j&lt;hi;j++) if(vec[j]&gt;vec[j+1])&#123; swap(vec[j],vec[j+1]); last=j; &#125; hi=last; &#125; &#125; 递归亦可实现。 选择排序改进 特点：每次循环找出最大和最小，使循环次数减半。 代码实现： 1234567891011121314151617181920void selet_sort(vector&lt;int&gt;&amp; vec)&#123; int maxi,mini; for(int i=0,k=vec.size()-1;i&lt;k;i++,k--)&#123; mini=i; maxi=k; for(int j=i;j&lt;=k;j++)&#123; if(vec[j]&gt;vec[maxi]) maxi=j; else if(vec[j]&lt;vec[mini]) mini=j; &#125; if(maxi==i&amp;&amp;mini==k) swap(vec[maxi],vec[mini]);// 若最大最小位置刚好相反，则只需交换一次。 else if(maxi==i)&#123; swap(vec[k],vec[maxi]); swap(vec[i],vec[mini]); //若最大位置为i，先交换最大。 &#125; else&#123; if(mini!=i) swap(vec[i],vec[mini]); if(maxi!=k) swap(vec[k],vec[maxi]); &#125; &#125;&#125; 注意特殊的几种情况。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vector总结（一）]]></title>
    <url>%2Fpost%2Fd907480.html</url>
    <content type="text"><![CDATA[主题：总结vector的二分查找及其应用 接口：二分查找 基础 没找到返回-1： 123456789int bin_Search(vector &amp;vec,int target)&#123; int lo=-1,hi=vec.size(); while(lo + 1 != hi)&#123; int mi=(lo+hi)&gt;&gt;1; if(vec[mi]&lt;target) lo=mi; else hi=mi; &#125; return -1;&#125; 例题可参考: 457. 经典二分查找问题 拓展一 没有找到返回最大或返回最左边： 123456789int bin_Search(vector &amp;vec,int target)&#123; int lo=-1,hi=vec.size(); //若起始位置改变，算法也要变 while(lo + 1 != hi)&#123; int mi=(lo+hi)&gt;&gt;1; A[mi]&lt;target?lo=mi:hi=mi;//记忆法：相等时左右移 &#125; //return hi;返回最左边（即可插入处），记忆法：hi的取值范围 //return lo;返回最大（包含-1），记忆法：lo的取值范围&#125; 例题可参考： 60. 搜索插入位置 14. 二分查找 拓展二 返回最右边： 12345678int bin_Search(vector &amp;vec,int target)&#123; int lo=-1,hi=vec.size(); //若起始位置改变，算法也要变 while(lo + 1 != hi)&#123; int mi=(lo+hi)&gt;&gt;1; A[mi]&lt;=target?lo=mi:hi=mi;//记忆法：相等时左右移 &#125; return lo;//记忆法：lo的取值范围&#125; 例题可参考： 61. 搜索区间 进阶 旋转数组（如：45123）： 例题一：找到最小值 159. 寻找旋转排序数组中的最小值 12345678int bin_Search(vector &amp;vec)&#123; int lo=-1,hi=vec.size()-1; //若起始位置改变，算法也要变 while(lo + 1 != hi)&#123; int mi=(lo+hi)&gt;&gt;1; A[mi]&gt;A[hi]?lo=mi:hi=mi; &#125; return hi;&#125; 例题二： 找特定值 62. 搜索旋转排序数组 123456789101112131415161718int search(vector&lt;int&gt; &amp;A, int target) &#123; // write your code here if(A.size()==0) return -1; int lo=0,hi=A.size()-1; while(lo &lt;= hi)&#123; int mi=(lo+hi)&gt;&gt;1; if(A[mi]==target) return mi; if(A[mi]&lt;A[hi])&#123; if(target&gt;A[mi]&amp;&amp;target&lt;=A[hi]) lo=mi+1;//位置缩小 else hi=mi-1; &#125; else&#123; if(target&lt;A[mi]&amp;&amp;target&gt;=A[lo]) hi=mi-1;//位置缩小 else lo=mi+1; &#125; &#125; return -1;&#125; 总结 二分查找可用于有序或部分有序的数组，其形式多变，需根据初始条件和范围选择合适的形式。 12345678910111213141516171819202122232425//二分查找的三种形式：//1.左开右开&#123; lo=-1,hi=size(); while(lo + 1 != hi)&#123; ... [mi]&lt;target?lo=mi:hi=mi; &#125;&#125;//2.左闭右开&#123; lo=0,hi=size(); while(lo&lt;hi)&#123; ... [mi]&lt;target?lo=mi+1:hi=mi; &#125;&#125;//3.左闭右闭&#123; lo=0,hi=size()-1 while(lo&lt;=hi)&#123; ... [mi]&lt;target?lo=mi+1:hi=mi-1; &#125;&#125; 参考文献：二分查找 二分查找问题汇总]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown测试]]></title>
    <url>%2Fpost%2F45babedb.html</url>
    <content type="text"><![CDATA[主题：简单介绍Typora的使用 typora快捷操作 快捷键 作用 快捷键 作用 Ctrl+1 一阶标题 Ctrl+B 字体加粗 Ctrl+2 二阶标题 Ctrl+I 字体倾斜 Ctrl+3 三阶标题 Ctrl+U 下划线 Ctrl+4 四阶标题 Ctrl+Home 返回Typora顶部 Ctrl+5 五阶标题 Ctrl+End 返回Typora底部 Ctrl+6 六阶标题 Ctrl+T 创建表格 Ctrl+L 选中某句话 Ctrl+K 创建超链接 Ctrl+D 选中某个单词 Ctrl+F 搜索 Ctrl+E 选中相同格式的文字 Ctrl+H 搜索并替换 Alt+Shift+5 删除线 Ctrl+Shift+I 插入图片 补充水平分割线（三个星） 引用（&gt; ） 与天奋斗，其乐无穷！与地奋斗，其乐无穷！与人奋斗，其乐无穷！———— 《毛泽东选集》之《奋斗自勉》（毛泽东1917年） 总结：typora是一个很好用的markdown编辑软件，今后我要尝试使用这个软件在github和微信公众号上发表博客，这将是我修行之路的开端。 2018/08/24另补充图片： 来源：《Markdown 实用指南》 作者：毕小烦]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>typora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[title : the introduction of hexo Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

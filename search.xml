<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vector总结（二）]]></title>
    <url>%2Fpost%2F2ab8ca21.html</url>
    <content type="text"><![CDATA[主题：数组的简单排序方法 插入排序 概念：插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)，是稳定的排序方法。 代码实现： 1234567891011void insert_sort(vector&lt;int&gt;&amp; vec)&#123; int n=vec.size(); for(int i=1;i&lt;n;i++)&#123; int j=i-1,tg=vec[i]; while(j&gt;=0&amp;&amp;vec[j]&gt;tg)&#123; vec[j+1]=vec[j];//插入 j--; &#125; vec[j+1]=tg; &#125;&#125; 特点：从前往后迭代，从后往前移动（插入特点）。 递归形式： 12345678910111213141516void insert_sort(vector&lt;int&gt;&amp; vec,int n)&#123; if(n==0) return; else&#123; insert_sort(vec,n-1);//前（n-1）排序 insert(vec,n);//插入第n个 &#125;&#125;void insert(vector&lt;int&gt;&amp;vec,int n)&#123; int i=n-1,tg=vec[n]; while(i&gt;=0&amp;&amp;vec[i]&gt;tg)&#123; vec[i+1]=vec[i]; i--; &#125; vec[i+1]=tg;&#125; 归并排序 概念：将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序，是稳定的排序方法。 代码实现： 123456789101112131415161718192021222324void merge_sort(vector&lt;int&gt;&amp; vec,int l,int r)&#123; if(l&gt;=r) return; else&#123; int mi=(l+r)&gt;&gt;1; merge_sort(vec,l,mi); merge_sort(vec,mi+1,r); merge(vec,l,mi,r); &#125;&#125;void merge(vector&lt;int&gt;&amp;vec,int l,int mi,int r)&#123; int l1=mi-l+1,l2=r-mi; int *A=new int[l1]; for(int i=0;i&lt;l1;i++) A[i]=vec[l+i]; int *B=new int[l2]; for(int i=0;i&lt;l2;i++) B[i]=vec[mi+1+i];//亦可设置哨兵 for(int i=0,j=0,k=l;i&lt;l1||j&lt;l2;k++)&#123; if(j==l2||(i&lt;l1&amp;&amp;j&lt;l2&amp;&amp;A[i]&lt;=B[j])) vec[k]=A[i++]; else vec[k]=B[j++]; &#125; delete []A; delete []B;&#125; 特点：分治法 时间复杂度：O(nlog n) 冒泡排序改进特点：检测最后的逆序对的位置，减少循环次数，但时间复杂度还是O(n)。 代码实现： 1234567891011121314void bubble_sort(vector&lt;int&gt;&amp; vec)&#123; int last,hi; hi=vec.size(); last=0;//最后的逆序对位置 for(int i=0;i&lt;hi;i++)&#123; for(int j=0;j&lt;hi;j++) if(vec[j]&gt;vec[j+1])&#123; swap(vec[j],vec[j+1]); last=j; &#125; hi=last; &#125; &#125; 递归亦可实现。 选择排序改进 特点：每次循环找出最大和最小，使循环次数减半。 代码实现： 1234567891011121314151617181920void selet_sort(vector&lt;int&gt;&amp; vec)&#123; int maxi,mini; for(int i=0,k=vec.size()-1;i&lt;k;i++,k--)&#123; mini=i; maxi=k; for(int j=i;j&lt;=k;j++)&#123; if(vec[j]&gt;vec[maxi]) maxi=j; else if(vec[j]&lt;vec[mini]) mini=j; &#125; if(maxi==i&amp;&amp;mini==k) swap(vec[maxi],vec[mini]);// 若最大最小位置刚好相反，则只需交换一次。 else if(maxi==i)&#123; swap(vec[k],vec[maxi]); swap(vec[i],vec[mini]); //若最大位置为i，先交换最大。 &#125; else&#123; if(mini!=i) swap(vec[i],vec[mini]); if(maxi!=k) swap(vec[k],vec[maxi]); &#125; &#125;&#125; 注意特殊的几种情况。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vector总结（一）]]></title>
    <url>%2Fpost%2Fd907480.html</url>
    <content type="text"><![CDATA[主题：总结vector的二分查找及其应用 接口：二分查找 基础 没找到返回-1： 123456789int bin_Search(vector &amp;vec,int target)&#123; int lo=-1,hi=vec.size(); while(lo + 1 != hi)&#123; int mi=(lo+hi)&gt;&gt;1; if(vec[mi]&lt;target) lo=mi; else hi=mi; &#125; return -1;&#125; 例题可参考: 457. 经典二分查找问题 拓展一 没有找到返回最大或返回最左边： 123456789int bin_Search(vector &amp;vec,int target)&#123; int lo=-1,hi=vec.size(); //若起始位置改变，算法也要变 while(lo + 1 != hi)&#123; int mi=(lo+hi)&gt;&gt;1; A[mi]&lt;target?lo=mi:hi=mi;//记忆法：相等时左右移 &#125; //return hi;返回最左边（即可插入处），记忆法：hi的取值范围 //return lo;返回最大（包含-1），记忆法：lo的取值范围&#125; 例题可参考： 60. 搜索插入位置 14. 二分查找 拓展二 返回最右边： 12345678int bin_Search(vector &amp;vec,int target)&#123; int lo=-1,hi=vec.size(); //若起始位置改变，算法也要变 while(lo + 1 != hi)&#123; int mi=(lo+hi)&gt;&gt;1; A[mi]&lt;=target?lo=mi:hi=mi;//记忆法：相等时左右移 &#125; return lo;//记忆法：lo的取值范围&#125; 例题可参考： 61. 搜索区间 进阶 旋转数组（如：45123）： 例题一：找到最小值 159. 寻找旋转排序数组中的最小值 12345678int bin_Search(vector &amp;vec)&#123; int lo=-1,hi=vec.size()-1; //若起始位置改变，算法也要变 while(lo + 1 != hi)&#123; int mi=(lo+hi)&gt;&gt;1; A[mi]&gt;A[hi]?lo=mi:hi=mi; &#125; return hi;&#125; 例题二： 找特定值 62. 搜索旋转排序数组 123456789101112131415161718int search(vector&lt;int&gt; &amp;A, int target) &#123; // write your code here if(A.size()==0) return -1; int lo=0,hi=A.size()-1; while(lo &lt;= hi)&#123; int mi=(lo+hi)&gt;&gt;1; if(A[mi]==target) return mi; if(A[mi]&lt;A[hi])&#123; if(target&gt;A[mi]&amp;&amp;target&lt;=A[hi]) lo=mi+1;//位置缩小 else hi=mi-1; &#125; else&#123; if(target&lt;A[mi]&amp;&amp;target&gt;=A[lo]) hi=mi-1;//位置缩小 else lo=mi+1; &#125; &#125; return -1;&#125; 总结 二分查找可用于有序或部分有序的数组，其形式多变，需根据初始条件和范围选择合适的形式。 12345678910111213141516171819202122232425//二分查找的三种形式：//1.左开右开&#123; lo=-1,hi=size(); while(lo + 1 != hi)&#123; ... [mi]&lt;target?lo=mi:hi=mi; &#125;&#125;//2.左闭右开&#123; lo=0,hi=size(); while(lo&lt;hi)&#123; ... [mi]&lt;target?lo=mi+1:hi=mi; &#125;&#125;//3.左闭右闭&#123; lo=0,hi=size()-1 while(lo&lt;=hi)&#123; ... [mi]&lt;target?lo=mi+1:hi=mi-1; &#125;&#125; 参考文献：二分查找 二分查找问题汇总]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown测试]]></title>
    <url>%2Fpost%2F45babedb.html</url>
    <content type="text"><![CDATA[主题：简单介绍Typora的使用 typora快捷操作 快捷键 作用 快捷键 作用 Ctrl+1 一阶标题 Ctrl+B 字体加粗 Ctrl+2 二阶标题 Ctrl+I 字体倾斜 Ctrl+3 三阶标题 Ctrl+U 下划线 Ctrl+4 四阶标题 Ctrl+Home 返回Typora顶部 Ctrl+5 五阶标题 Ctrl+End 返回Typora底部 Ctrl+6 六阶标题 Ctrl+T 创建表格 Ctrl+L 选中某句话 Ctrl+K 创建超链接 Ctrl+D 选中某个单词 Ctrl+F 搜索 Ctrl+E 选中相同格式的文字 Ctrl+H 搜索并替换 Alt+Shift+5 删除线 Ctrl+Shift+I 插入图片 补充水平分割线（三个星） 引用（&gt; ） 与天奋斗，其乐无穷！与地奋斗，其乐无穷！与人奋斗，其乐无穷！———— 《毛泽东选集》之《奋斗自勉》（毛泽东1917年） 总结：typora是一个很好用的markdown编辑软件，今后我要尝试使用这个软件在github和微信公众号上发表博客，这将是我修行之路的开端。 2018/08/24另补充图片： 来源：《Markdown 实用指南》 作者：毕小烦]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>typora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[title : the introduction of hexo Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
